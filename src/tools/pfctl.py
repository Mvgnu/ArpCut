import sys
import re
from subprocess import run, PIPE

ANCHOR = 'com.arpcut'
_LAST_ERR = ''

# Regex for valid IPv4
_IP_RE = re.compile(r'^(\d{1,3}\.){3}\d{1,3}$')


def _is_valid_ip(ip: str) -> bool:
    """Check if string is a valid IPv4 address."""
    if not ip or not _IP_RE.match(ip):
        return False
    parts = ip.split('.')
    return all(0 <= int(p) <= 255 for p in parts)


def _exec(cmd):
    return run(cmd, shell=True, stdout=PIPE, stderr=PIPE, text=True)


def _set_err(msg: str):
    global _LAST_ERR
    _LAST_ERR = msg or ''


def last_error() -> str:
    return _LAST_ERR


def _is_valid_pf_rule(rule: str) -> bool:
    """Check if a pf rule looks valid (basic sanity check)."""
    if not rule or rule.startswith('#'):
        return False
    # Must start with 'block' and contain valid-looking IPs or 'any'
    if not rule.startswith('block'):
        return False
    # Check that any IP-like strings in the rule are actually valid IPs or 'any'
    parts = rule.split()
    for i, part in enumerate(parts):
        if part in ('from', 'to') and i + 1 < len(parts):
            next_part = parts[i + 1]
            if next_part != 'any' and not _is_valid_ip(next_part):
                return False
    return True


def _read_existing_rules() -> list[str]:
    """Read existing rules from anchor file, filtering out comments, empty lines, and invalid rules."""
    try:
        path = _anchor_file()
        with open(path, 'r') as f:
            lines = f.readlines()
        valid = []
        for line in lines:
            line = line.strip()
            if line and not line.startswith('#') and _is_valid_pf_rule(line):
                valid.append(line)
        return valid
    except Exception:
        return []


def clear_anchor() -> bool:
    """Clear all rules from the anchor file."""
    if sys.platform != 'darwin':
        return True
    try:
        path = _anchor_file()
        with open(path, 'w') as f:
            f.write("# ArpCut anchor - autogenerated\n")
        _exec(f"pfctl -a {ANCHOR} -f {path}")
        return True
    except Exception:
        return False


def _write_pf_rules(new_rules: list[str], replace: bool = False) -> bool:
    """
    Write rules to pf anchor file and reload.
    If replace=False, appends to existing rules.
    If replace=True, overwrites all rules.
    Returns True on success, False on any error.
    """
    if not ensure_pf_enabled() or not install_anchor():
        return False
    try:
        path = _anchor_file()
        if replace:
            all_rules = new_rules
        else:
            all_rules = _read_existing_rules() + new_rules
        
        with open(path, 'w') as f:
            f.write("# ArpCut anchor - autogenerated\n")
            for rule in all_rules:
                f.write(f"{rule}\n")
        res = _exec(f"pfctl -a {ANCHOR} -f {path}")
        if res.returncode != 0:
            _set_err(res.stderr or res.stdout or 'pfctl failed')
            return False
        _set_err('')
        return True
    except Exception as e:
        _set_err(str(e))
        return False


def ensure_pf_enabled():
    if sys.platform != 'darwin':
        return True
    status = _exec('pfctl -s info')
    if status.returncode != 0:
        _set_err(status.stderr or status.stdout or 'pfctl -s info failed')
        return False
    if 'Status: Enabled' in status.stdout:
        return True
    # Try to enable
    en = _exec('pfctl -E')
    if en.returncode != 0:
        _set_err(en.stderr or en.stdout or 'pfctl -E failed')
    else:
        _set_err('')
    return en.returncode == 0


def _anchor_file():
    return f'/etc/pf.anchors/{ANCHOR}'


def install_anchor():
    if sys.platform != 'darwin':
        return True
    path = _anchor_file()
    # Clean the anchor file first - remove any garbage/invalid rules
    try:
        if _exec(f"test -f {path}").returncode == 0:
            # File exists - read and filter
            with open(path, 'r') as f:
                lines = f.readlines()
            valid = []
            for line in lines:
                line = line.strip()
                if line and not line.startswith('#') and _is_valid_pf_rule(line):
                    valid.append(line)
            # Rewrite with only valid rules
            with open(path, 'w') as f:
                f.write("# ArpCut anchor - autogenerated\n")
                for rule in valid:
                    f.write(f"{rule}\n")
        else:
            # File doesn't exist - create empty
            with open(path, 'w') as f:
                f.write("# ArpCut anchor - autogenerated\n")
    except Exception as e:
        _set_err(f'failed to clean anchor file: {e}')
        return False
    
    # Ensure pf.conf references our anchor
    try:
        with open('/etc/pf.conf', 'r') as f:
            conf = f.read()
        if f'anchor "{ANCHOR}"' not in conf and f'load anchor "{ANCHOR}"' not in conf:
            with open('/etc/pf.conf', 'a') as f:
                f.write(f"\n# ArpCut anchor\nanchor \"{ANCHOR}\"\nload anchor \"{ANCHOR}\" from \"{_anchor_file()}\"\n")
    except Exception:
        _set_err('failed to read/write /etc/pf.conf')
        return False
    
    # Load the (now clean) anchor
    res = _exec(f"pfctl -a {ANCHOR} -f {path}")
    if res.returncode != 0:
        _set_err(res.stderr or res.stdout or 'pfctl anchor load failed')
        return False
    _set_err('')
    return True


def list_rules():
    if sys.platform != 'darwin':
        return []
    if not ensure_pf_enabled() or not install_anchor():
        return []
    res = _exec(f'pfctl -a {ANCHOR} -s rules')
    if res.returncode != 0:
        _set_err(res.stderr or res.stdout or 'pfctl list failed')
        return []
    _set_err('')
    return res.stdout.splitlines()


def block_dst(iface: str, victim_ip: str, dst_ip: str, port: int | None = None, proto: str | None = None):
    if sys.platform != 'darwin':
        # Windows: use netsh advfirewall (simplified - block destination IP)
        if sys.platform.startswith('win'):
            rule_name = f'arpcut_{victim_ip.replace(".", "_")}_to_{dst_ip.replace(".", "_")}'
            if port:
                rule_name += f'_p{port}'
            cmd = f'netsh advfirewall firewall add rule name="{rule_name}" dir=out action=block remoteip={dst_ip} enable=yes'
            if port:
                cmd += f' protocol={proto.lower() if proto else "TCP"} localport={port}'
            res = _exec(cmd)
            return res.returncode == 0
        return False
    port_clause = f' port {port}' if port else ''
    proto_clause = f' proto {proto.lower()}' if proto and proto.upper() in ['TCP','UDP'] else ''
    # macOS anchors don't support 'in'/'out' - omit direction
    rule = f'block drop quick on {iface}{proto_clause} from {victim_ip} to {dst_ip}{port_clause}'
    return _write_pf_rules([rule], replace=False)


def unblock_dst(dst_ip: str, port: int | None = None):
    if sys.platform != 'darwin':
        # Windows: remove firewall rule by name pattern
        if sys.platform.startswith('win'):
            # List rules and delete matching ones
            list_cmd = 'netsh advfirewall firewall show rule name=all dir=out'
            res = _exec(list_cmd)
            if res.returncode == 0:
                lines = res.stdout.splitlines()
                rule_name = None
                for line in lines:
                    if 'arpcut' in line.lower() and dst_ip.replace('.', '_') in line:
                        # Extract rule name from line like "Rule Name: elmocut_..."
                        if 'Rule Name:' in line:
                            rule_name = line.split('Rule Name:')[1].strip()
                            _exec(f'netsh advfirewall firewall delete rule name="{rule_name}"')
            return True
        return False
    # Safely rewrite the anchor file without shell quoting issues
    try:
        path = _anchor_file()
        with open(path, 'r') as f:
            lines = f.readlines()
        with open(path, 'w') as f:
            for line in lines:
                if dst_ip not in line:
                    f.write(line)
        _exec(f"pfctl -a {ANCHOR} -f {path}")
        return True
    except Exception:
        return False


def export_rules(path: str):
    try:
        with open(_anchor_file(), 'r') as src, open(path, 'w') as dst:
            dst.write(src.read())
        return True
    except Exception:
        return False


def import_rules(path: str):
    try:
        with open(path, 'r') as src, open(_anchor_file(), 'w') as dst:
            dst.write(src.read())
        _exec(f"pfctl -a {ANCHOR} -f {_anchor_file()}")
        return True
    except Exception:
        return False


def is_blocked(dst_ip: str) -> bool:
    if sys.platform != 'darwin':
        return False
    rules = list_rules()
    return any(dst_ip in r for r in rules)


def pf_self_check() -> bool:
    if sys.platform != 'darwin':
        # Windows: check if firewall is accessible
        if sys.platform.startswith('win'):
            res = _exec('netsh advfirewall show allprofiles state')
            return res.returncode == 0 and 'ON' in res.stdout
        return True
    if not ensure_pf_enabled():
        return False
    return install_anchor()


def block_all_for(iface: str, victim_ip: str) -> bool:
    if sys.platform != 'darwin':
        # Windows: use netsh advfirewall
        if sys.platform.startswith('win'):
            rule_name = f'arpcut_block_{victim_ip.replace(".", "_")}'
            cmd = f'netsh advfirewall firewall add rule name="{rule_name}" dir=out action=block remoteip={victim_ip} enable=yes'
            res = _exec(cmd)
            return res.returncode == 0
        return False
    # macOS anchors don't support 'in'/'out' - omit direction
    rule = f'block drop quick on {iface} from {victim_ip} to any'
    return _write_pf_rules([rule], replace=False)


def unblock_all_for(victim_ip: str) -> bool:
    if sys.platform != 'darwin':
        # Windows: remove firewall rule
        if sys.platform.startswith('win'):
            rule_name = f'arpcut_block_{victim_ip.replace(".", "_")}'
            cmd = f'netsh advfirewall firewall delete rule name="{rule_name}"'
            _exec(cmd)  # Ignore return code (rule may not exist)
            return True
        return False
    try:
        path = _anchor_file()
        with open(path, 'r') as f:
            lines = f.readlines()
        with open(path, 'w') as f:
            for line in lines:
                if f'from {victim_ip} ' not in line:
                    f.write(line)
        _exec(f"pfctl -a {ANCHOR} -f {path}")
        return True
    except Exception:
        return False


def pf_test_roundtrip(iface: str, victim_ip: str) -> bool:
    if sys.platform != 'darwin':
        return True
    tmp_ip = '203.0.113.9'
    ok1 = block_all_for(iface, victim_ip)
    rules = list_rules()
    present = any(victim_ip in r for r in rules)
    ok2 = unblock_all_for(victim_ip)
    return ok1 and present and ok2


# ============== IP BLOCKING ==============

def block_ip(iface: str, ip: str, direction: str = 'both') -> bool:
    """Block all traffic to/from a specific IP."""
    # Validate IP first
    if not _is_valid_ip(ip):
        _set_err(f'Invalid IP address: {ip}')
        return False
    
    if sys.platform == 'darwin':
        # macOS anchors don't support 'in'/'out' keywords - blocks both directions
        # Block traffic FROM the IP and TO the IP
        rules = [
            f'block drop quick on {iface} from {ip} to any',
            f'block drop quick on {iface} from any to {ip}'
        ]
        return _write_pf_rules(rules, replace=False)
    elif sys.platform.startswith('win'):
        rule_name = f'arpcut_ip_{ip.replace(".", "_")}'
        ok = True
        if direction in ('in', 'both'):
            res = _exec(f'netsh advfirewall firewall add rule name="{rule_name}_in" dir=in action=block remoteip={ip} enable=yes')
            ok = ok and res.returncode == 0
        if direction in ('out', 'both'):
            res = _exec(f'netsh advfirewall firewall add rule name="{rule_name}_out" dir=out action=block remoteip={ip} enable=yes')
            ok = ok and res.returncode == 0
        if not ok:
            _set_err(res.stderr or res.stdout or 'netsh failed')
        else:
            _set_err('')
        return ok
    return False


def unblock_ip(ip: str) -> bool:
    """Remove IP blocking rules."""
    if sys.platform == 'darwin':
        try:
            path = _anchor_file()
            with open(path, 'r') as f:
                lines = f.readlines()
            with open(path, 'w') as f:
                for line in lines:
                    if f'from {ip} ' not in line and f'to {ip}' not in line:
                        f.write(line)
            res = _exec(f"pfctl -a {ANCHOR} -f {path}")
            if res.returncode != 0:
                _set_err(res.stderr or res.stdout or 'pfctl failed')
                return False
            _set_err('')
            return True
        except Exception as e:
            _set_err(str(e))
            return False
    elif sys.platform.startswith('win'):
        rule_name = f'arpcut_ip_{ip.replace(".", "_")}'
        res_in = _exec(f'netsh advfirewall firewall delete rule name="{rule_name}_in"')
        res_out = _exec(f'netsh advfirewall firewall delete rule name="{rule_name}_out"')
        ok = (res_in.returncode == 0) or (res_out.returncode == 0)
        if not ok:
            _set_err((res_in.stderr or '') + '\n' + (res_out.stderr or ''))
        else:
            _set_err('')
        return ok
    return False


def list_blocked_ips() -> list:
    """Return list of blocked IPs as [(ip, direction), ...]"""
    blocked = []
    if sys.platform == 'darwin':
        rules = list_rules()
        for rule in rules:
            if 'block drop quick' in rule and 'port' not in rule:
                parts = rule.split()
                try:
                    if 'from' in parts and 'to' in parts:
                        from_idx = parts.index('from')
                        to_idx = parts.index('to')
                        from_ip = parts[from_idx + 1]
                        to_ip = parts[to_idx + 1]
                        # Determine direction based on rule structure:
                        # "from {IP} to any" = blocks incoming from that IP
                        # "from any to {IP}" = blocks outgoing to that IP
                        if from_ip != 'any':
                            blocked.append((from_ip, 'in'))  # blocks traffic FROM this IP
                        elif to_ip != 'any':
                            blocked.append((to_ip, 'out'))  # blocks traffic TO this IP
                except (ValueError, IndexError):
                    pass
    elif sys.platform.startswith('win'):
        import re
        res = _exec('netsh advfirewall firewall show rule name=all')
        if res.returncode == 0:
            regex = re.compile(r'arpcut_ip_([0-9]{1,3}(?:_[0-9]{1,3}){3})_(in|out)', re.IGNORECASE)
            for line in res.stdout.splitlines():
                line = line.strip()
                if 'arpcut_ip_' in line.lower():
                    m = regex.search(line)
                    if m:
                        ip = m.group(1).replace('_', '.')
                        direction = m.group(2)
                        blocked.append((ip, direction))
    return blocked


# ============== PORT BLOCKING ==============

def block_port(iface: str, port: int, proto: str = 'tcp', direction: str = 'both', target_ip: str = None) -> bool:
    """
    Block a specific port on the network interface.
    If target_ip is provided, only blocks that port for traffic from/to that IP.
    direction: ignored on macOS (anchors don't support in/out)
    """
    if sys.platform == 'darwin':
        # macOS anchors don't support 'in'/'out' keywords
        if target_ip:
            # Block port only for specific device
            rule = f'block drop quick on {iface} proto {proto} from {target_ip} to any port {port}'
        else:
            # Block port for all traffic
            rule = f'block drop quick on {iface} proto {proto} from any to any port {port}'
        return _write_pf_rules([rule], replace=False)
    elif sys.platform.startswith('win'):
        rule_name = f'arpcut_port_{port}_{proto}'
        ok = True
        if direction in ('in', 'both'):
            res = _exec(f'netsh advfirewall firewall add rule name="{rule_name}_in" dir=in action=block protocol={proto} localport={port} enable=yes')
            ok = ok and res.returncode == 0
        if direction in ('out', 'both'):
            res = _exec(f'netsh advfirewall firewall add rule name="{rule_name}_out" dir=out action=block protocol={proto} localport={port} enable=yes')
            ok = ok and res.returncode == 0
        if not ok:
            _set_err((res.stderr or res.stdout or 'netsh failed'))
        else:
            _set_err('')
        return ok
    return False


def unblock_port(port: int, proto: str = 'tcp') -> bool:
    """Remove port blocking rules for the specified port."""
    if sys.platform == 'darwin':
        try:
            path = _anchor_file()
            with open(path, 'r') as f:
                lines = f.readlines()
            with open(path, 'w') as f:
                for line in lines:
                    if f'port = {port}' not in line:
                        f.write(line)
            _exec(f"pfctl -a {ANCHOR} -f {path}")
            return True
        except Exception:
            return False
    elif sys.platform.startswith('win'):
        rule_name = f'arpcut_port_{port}_{proto}'
        res_in = _exec(f'netsh advfirewall firewall delete rule name="{rule_name}_in"')
        res_out = _exec(f'netsh advfirewall firewall delete rule name="{rule_name}_out"')
        ok = (res_in.returncode == 0) or (res_out.returncode == 0)
        if not ok:
            _set_err((res_in.stderr or '') + '\\n' + (res_out.stderr or ''))
        else:
            _set_err('')
        return ok
    return False


def is_port_blocked(port: int) -> bool:
    """Check if a port is currently blocked."""
    if sys.platform == 'darwin':
        rules = list_rules()
        return any(f'port = {port}' in r for r in rules)
    elif sys.platform.startswith('win'):
        res = _exec(f'netsh advfirewall firewall show rule name="arpcut_port_{port}_tcp_in"')
        return 'arpcut_port' in res.stdout.lower()
    return False


def list_blocked_ports() -> list:
    """Return list of currently blocked ports as [(port, proto, direction), ...]"""
    blocked = []
    if sys.platform == 'darwin':
        rules = list_rules()
        for rule in rules:
            if 'port =' in rule:
                # Parse rule like: block drop quick in on en0 proto tcp from any to any port = 443
                parts = rule.split()
                try:
                    port_idx = parts.index('port')
                    port = int(parts[port_idx + 2])
                    proto = 'tcp'
                    if 'proto' in parts:
                        proto_idx = parts.index('proto')
                        proto = parts[proto_idx + 1]
                    direction = 'in' if ' in on ' in rule else 'out'
                    blocked.append((port, proto, direction))
                except (ValueError, IndexError):
                    pass
    elif sys.platform.startswith('win'):
        import re
        res = _exec('netsh advfirewall firewall show rule name=all')
        if res.returncode == 0:
            regex = re.compile(r'arpcut_port_([0-9]+)_([a-z]+)_(in|out)', re.IGNORECASE)
            for line in res.stdout.splitlines():
                line = line.strip()
                if 'arpcut_port_' in line.lower():
                    m = regex.search(line)
                    if m:
                        port = int(m.group(1))
                        proto = m.group(2)
                        direction = m.group(3)
                        blocked.append((port, proto, direction))
    return blocked


def clear_all_port_blocks() -> bool:
    """Remove all port blocking rules."""
    if sys.platform == 'darwin':
        try:
            path = _anchor_file()
            with open(path, 'r') as f:
                lines = f.readlines()
            with open(path, 'w') as f:
                for line in lines:
                    if 'port =' not in line:
                        f.write(line)
            _exec(f"pfctl -a {ANCHOR} -f {path}")
            return True
        except Exception:
            return False
    elif sys.platform.startswith('win'):
        # Delete all arpcut_port rules
        res = _exec('netsh advfirewall firewall show rule name=all')
        if res.returncode == 0:
            for line in res.stdout.splitlines():
                if 'arpcut_port' in line.lower() and 'Rule Name:' in line:
                    rule_name = line.split('Rule Name:')[1].strip()
                    _exec(f'netsh advfirewall firewall delete rule name="{rule_name}"')
        return True
    return False


